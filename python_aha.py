import sys, os, socket, time, json, io
from io import open
from datetime import datetime
from subprocess import Popen, PIPE
from sets import Set
import hashlib 
import time
import shlex

#NOTE: Duplicate info is a manuel process in Duplicate_Entry function
class ScanInfo:
  def __init__(self):
    self.fields = [ 'ProcessName', 'PID', 'PPID', 'ProcessPath', 'Protocol', 
                    'LocalAddress', 
                    'LocalPort', 'LocalHostName', 'LocalPortName', 'RemoteAddress', 
                    'RemotePort', 'RemoteHostName', 'RemotePortName', 'State', 
                    'ProductName', 'FileDescription', 'FileVersion', 'Company', 
                    'ProcessCreatedOn', 'UserName', 'ProcessServices', 'ProcessAttributes', 
                    'DetectionTime', 'ARCH', 'ASLR', 'PIE-Binary', 'DEP', 'RELRO', 
                    'StackCanary', 'INODE', 'CLIArguments', 'ExtraConnectionInfo',
                    'SumMD5', 'SumSHA1', 'SumSHA256', 'SumSHA512']
  
  def CreateBlank(self):
    blank = {}
    for field in self.fields:
      blank[field] = ''
    #Fix none string & defaults
    blank['PID'] = 0
    blank['PPID'] = 0
    blank['ProcessName'] = 'Unknown'
    blank['Protocol'] = 'none'
    blank['ASLR'] = 'ScanError'
    blank['PIE-Binary'] = 'ScanError'
    blank['DEP'] = 'ScanError'
    blank['RELRO'] = 'ScanError'
    blank['StackCanary'] = 'ScanError'
    blank['SumMD5'] = 'ScanError'
    blank['SumSHA1'] = 'ScanError'
    blank['SumSHA256'] = 'ScanError'
    blank['SumSHA512'] = 'ScanError'
    blank['CLIArguments'] = 'N/A'
    blank['ExtraConnectionInfo'] = 'N/A'
    return blank
  
  def CopyOver(self, dest, source):
    non = {'Unknown', 'none', 'ScanError', 'N/A', ''}
    for field in self.fields:
      dest[field] = source[field] 
  
  def Header(self):
    list = []
    for field in self.fields:
      list.append('"'+field+'"')
    cur = ','.join(list)
    return cur
  
  def String(self, ob):
    list = []
    for field in self.fields:
      list.append('"'+str(ob[field])+'"')
    cur = ','.join(list)
    cur = cur.replace('\n', '')
    return cur


#TODO: fix user control over debugging
#Debug variable, controls test printing for each function output
#If Debug=4, output needed input
#If Debug=5, input needed input from a debug=4 run. !Extra param needed for file name!
VERSION="19.8.2"
DEBUG=0
SysASLR = ''
ProcASLR = ''
PIE_process = ''
ScanTimeString = ''
#Holds netstat output with Addresses resolved
netstat_names = Set()
#Contains ordered entries of processes
printList = []
#Contains all popen commands if debug=4/5
debugRecall = []
debugRecallFile = ''
outFile = ''

#Use the comment bellow to show a arg function sets this argument
#ARG 'name' 
argMap = {}  #Put arguments in here for other functions to check for. Value can be dummy value

procList = []  #Used to skip procs that are generated by the program

#Holds info for current proc
infoGen = ScanInfo()
CurrentProc = infoGen.CreateBlank()

#dictionary that holds entries for PIDs
#   access specific values by: procDict[pid][varName]
procDict = {}
#-----------------------Helper Functions ----------------------------------------  

#geeksforgeeks provided.
class Colors: 
  '''Colors class:reset all colors with colors.reset; two  
  sub classes fg for foreground  
  and bg for background; use as colors.subclass.colorname. 
  i.e. colors.fg.red or colors.bg.greenalso, the generic bold, disable,  
  underline, reverse, strike through, 
  and invisible work with the main class i.e. colors.bold'''
  reset='\033[0m'
  bold='\033[01m'
  disable='\033[02m'
  underline='\033[04m'
  reverse='\033[07m'
  strikethrough='\033[09m'
  invisible='\033[08m'
  cursorClear='\033[?25l'
  cursorRst='\033[?25h'
  class fg: 
      black='\033[30m'
      red='\033[31m'
      green='\033[32m'
      orange='\033[33m'
      blue='\033[34m'
      purple='\033[35m'
      cyan='\033[36m'
      lightgrey='\033[37m'
      darkgrey='\033[90m'
      lightred='\033[91m'
      lightgreen='\033[92m'
      yellow='\033[93m'
      lightblue='\033[94m'
      pink='\033[95m'
      lightcyan='\033[96m'
  class bg: 
      black='\033[40m'
      red='\033[41m'
      green='\033[42m'
      orange='\033[43m'
      blue='\033[44m'
      purple='\033[45m'
      cyan='\033[46m'
      white='\033[47m'


def Warn(str):
  print(Colors.fg.orange + 'Warning! ' + str + Colors.reset)

def ErrorExit(str):
  sys.exit(Colors.fg.red + 'ERROR!! ' + str + Colors.reset)


#Wrap around every Popen, not popen. Should have stdout and stderr
#Ex: Popen_Wrapper(Popen(cmd, shell=True, stdout=PIPE, stderr=PIPE))
def Popen_Wrapper(process, input=None):
  global debugRecall
  procList.append(process.pid)
  if input != None:
    (o, e) = process.communicate(input=input)
  else:
    (o, e) = process.communicate()
  if 'recall-in' in argMap:
    #Nothing left, probably a older version debug recall
    if len(debugRecall) == 0:
      return ('', '')
    #Get stdout
    o = str(debugRecall[0])
    debugRecall = debugRecall[1:]
    if len(debugRecall) == 0:
      return (o, '')
    #Get stderr
    e = str(debugRecall[0])
    debugRecall = debugRecall[1:]
  else:
    if 'recall-out' in argMap:
      debugRecall.append(o)
      debugRecall.append(e)
  return (o, e)

def PrintFull(str):
  sys.stdout.write(str)
  sys.stdout.flush()

#Prints a progress bar when not in debug mode
#Use Print at any progress marks. Points can be skipped. 
#Use End when done to finish the terminal output.
class Progress_Bar:
  def __init__(self, total):
    self.started = False
    self.total = total if total != 0 else 1
    self.inc = 0
    self.c = 0

  def Inc(self, step):
    self.inc += step

  def Set(self, prog):
    self.inc = prog

  def __PrintBar(self):
    """ val is from 0 to 10
    """
    # Print bar
    step = float(self.inc) / float(self.total)
    step = int(step * 10.0) % 11  #Round
    sys.stdout.write(' [')
    sys.stdout.write(Colors.bg.white)
    for i in range(0, step):
      sys.stdout.write(' ')
    sys.stdout.write(Colors.reset)
    for j in range(0, 10-step):
      sys.stdout.write(' ')
    sys.stdout.write(']')

    #Print thinking
    self.c = (self.c + 1) % 4
    if self.inc == self.total:
      sys.stdout.write(' ')
    elif self.c % 4 == 0:
      sys.stdout.write('-')
    elif self.c % 4 == 1:
      sys.stdout.write('\\')
    elif self.c % 4 == 2:
      sys.stdout.write('|')
    else:
      sys.stdout.write('/')

    sys.stdout.flush()
  
  def _PrintStart(self):
    sys.stdout.write('')
    #sys.stdout.write(Colors.cursorClear)
    self.__PrintBar()
    self.started = True

  def _PrintRest(self):
    sys.stdout.write('\r')
    self.__PrintBar()

  def Print(self):
    if DEBUG == 0:
      if not self.started:
        self._PrintStart()
      else:
        self._PrintRest()
    
  def End(self):
    sys.stdout.write('\r')
    self.inc = self.total
    self.__PrintBar()
    sys.stdout.write(Colors.cursorRst)
    sys.stdout.flush()
    print(' ')  #Move to next line
    


#Converts the input date format and returns the preferred output date format
#Learned: How to only show selected columns of 'ps' , how to grep for PID using ps output, converting date time formats, tokenizing (I had a few iterations of this function)
def Convert_Date(oldformat):
  if(DEBUG > 0):
    print('Convert_Date()------------------------------------')
  datetimeobject = datetime.strptime(oldformat, '%Y-%m-%d %H:%M:%S.%f')
  newformat = datetimeobject.strftime('%m/%d/%Y %H:%M')
  return newformat

#Gets the current date / time and formats it to the preferred output
def Detection_Time():
  global ScanTimeString
  if(DEBUG > 0):
    print('Detection_Time()------------------------------------')
  detectionTime, e = Popen_Wrapper(Popen(shlex.split("date '+%m/%d/%Y %H:%M'"), shell=False,
                                         stdout=PIPE, stderr=PIPE))
  ScanTimeString = Clean_String(detectionTime)
  if(DEBUG > 0):
    print('Time Detected: '+CurrentProc['DetectionTime'])

#Removes duplicate spaces, trailing whitespace, and newline chars
# and returns result
def Clean_String(s):
  #Remove trailing newline and whitespaces
  s.rstrip()
  #Remove extra whtiespace
  s = ' '.join(s.split())
  return s

#Accepts a string value and checks if the string is an integer
#Returns a boolean value
def Is_Int(s):
  try: 
    int(s)
    return True
  except ValueError as e:
    return False


#-----------------------Auxhilary Functions ------------------------------
#Creates initial dictionary entry '0'
def Init_Dict():
  procDict[0] = infoGen.CreateBlank()
  
#Checks if the process path is empty and sets values appropriately
def Proc_Check(path):
  if(DEBUG > 0):
    print("Proc_Check() |"+str(path)+'|')
  if (path == ''):
    CurrentProc['RELRO']='ScanError'
    CurrentProc['StackCanary']='ScanError'
    CurrentProc['DEP']='ScanError'
  else:
    RELRO(path)
    Stack_Canary(path)
    DEP_NX_Enabled(path)

#Gets and sets the current Architecture
#TODO: support other architectures
def Architecture(pid):
  if(DEBUG > 0):
    print('Architecture() PID: |'+str(pid)+'|------------------------------------')
  #Check for valid pid
  if(pid <= 0):
    CurrentProc['ARCH']= 'ScanError'
    return
  ARCH, e = Popen_Wrapper(Popen(shlex.split("file -L /proc/"+str(pid)+'/exe'), 
                                shell=False, stdout=PIPE, stderr=PIPE))
  ARCH = Clean_String(ARCH)
  ARCH = ARCH.split(',')
  ARCH = ARCH[1] if len(ARCH) > 1 else ''
  #Check if we need to standardize the architecture
  if(('x86-64' in ARCH) or ('AMD64' in ARCH)):
    ARCH = 'AMD64'
  if len(ARCH) == 0:
    #Check if kernel sub process
    if len(CurrentProc['ProcessName']) > 0 and CurrentProc['ProcessName'][0] == '[':
      ARCH, e = Popen_Wrapper(Popen(shlex.split('uname -a'), shell=False, stdout=PIPE, stderr=PIPE))
      if(('x86-64' in ARCH) or ('x86_64' in ARCH) or ('AMD64' in ARCH)):
        ARCH = 'AMD64'
      else:
        ARCH = 'ScanError'
    else:
      ARCH = 'ScanError'
  if(DEBUG > 1):
    print('ARCH: |'+str(ARCH)+'|')
  CurrentProc['ARCH']=ARCH

#Accepts a CurrentProc structure and inserts it into the ordered printList, ordered by PID
def Insert_Print_List(curProc):
  curProc['DetectionTime'] = ScanTimeString  # Put time back in
  if len(curProc['ProcessName']) == 0:
    curProc['ProcessName'] = 'ScanError'  # Oopsie 
  #define a counter variable
  i = 0
  #capture pid for current proc:
  pid = int(curProc['PID'])

  if(DEBUG > 0):
    print('Insert_Print_List() with PID |'+str(pid)+'|------------------------------------')
  if(DEBUG > 2):
    print('currentProc: ')
    print(curProc)

  #Check if the list is empty
  if (len(printList) == 0):
    if(DEBUG > 2):
      print('printList was empty')
    printList.insert(0,curProc)
    return
  
  #Find where to insert within the list
  for x in printList:
    #If we are less than the current index, insert
    if (pid < int(x['PID'])):
      break
    else:
      i +=1
  printList.insert(i, curProc)
  if(DEBUG > 2):
    print('Inserting PID: '+str(pid)+' into printList at index: '+str(i))
    print("Resulting List: " +str(printList))
#Adds a unique entry to the dictionary based on PID, must be int
def Add_Entry(pid):
  #Make sure int
  if type(pid) != type(0):
    ErrorExit('Add_entry requires int type for pid')
  if CurrentProc['PID'] in procList:
    if DEBUG > 0:
      print('Add_Entry Skipping %s pid')
    return 
  #temporary variable to hold proc information and create new memory for entries in printList
  #NOTE: cannot simply insert CurrentProc entry to printList sicne the memory address is the same
  #As such, inserting CurrentProc multiple times and modifying results in all entries being changed
  #To the latest data stored in CurrentProc
  curProc = infoGen.CreateBlank()
  
  #Check if IPv6 Protocol, parse out '6'
  if('6' in CurrentProc['Protocol']):
    if('tcp' in CurrentProc['Protocol']):
      CurrentProc['Protocol'] = 'tcp'
    else:
      CurrentProc['Protocol'] = 'udp'
  
  #Set entry to new dictionary
  procDict[pid] = {}
  if(DEBUG > 0):
    print('Add_Entry() PID: |'+str(pid)+'|------------------------------------')

  #Store entry in procDict for duplicate entries
  infoGen.CopyOver(procDict[pid], CurrentProc)

  #NOTE: Had to build string manually; iteration over the object didn't produce expected order
  #Create string to print to to file:
  infoGen.CopyOver(curProc, CurrentProc)
  #Insert entry into our printList
  Insert_Print_List(curProc)

#A duplicate entry has been detected, do not scan again and reprint info to file
#   How to acces entry variables: procDict[pid][varName]
def Duplicate_Entry(pid):
  #Make sure int
  if type(pid) != type(0):
    ErrorExit('Duplicate requires pid to be int type.')
  if (DEBUG > 0):
    print('Duplicate_Entry() |'+str(pid)+'|------------------------------------')
  #Call architecture function
  Architecture(pid)
  #Check if IPv6 Protocol
  if('6' in CurrentProc['Protocol']):
    if('tcp' in CurrentProc['Protocol']):
      CurrentProc['Protocol'] = 'tcp'
    else:
      CurrentProc['Protocol'] = 'udp'
  
  #temporary variable to hold proc information
  curProc = infoGen.CreateBlank()
  #NOTE: Had to build string manually; iteration over the object didn't produce expected order
  #Create string to print to to file:
  infoGen.CopyOver(curProc, CurrentProc)
  # Fill in duplicate info
  curProc['ProcessName'] = procDict[pid]['ProcessName']
  curProc['PID'] = procDict[pid]['PID']
  curProc['PPID'] = procDict[pid]['PPID']
  curProc['ProcessPath'] = procDict[pid]['ProcessPath']
  curProc['ProductName'] = procDict[pid]['ProductName']
  curProc['FileDescription'] = procDict[pid]['FileDescription']
  curProc['FileVersion'] = procDict[pid]['FileVersion']
  curProc['Company'] = procDict[pid]['Company']
  curProc['ProcessCreatedOn'] = procDict[pid]['ProcessCreatedOn']
  curProc['UserName'] = procDict[pid]['UserName']
  curProc['ProcessServices'] = procDict[pid]['ProcessServices']
  curProc['ProcessAttributes'] = procDict[pid]['ProcessAttributes']
  curProc['ASLR'] = procDict[pid]['ASLR']
  curProc['PIE-Binary'] = procDict[pid]['PIE-Binary']
  curProc['DEP'] = procDict[pid]['DEP']
  curProc['RELRO'] = procDict[pid]['RELRO']
  curProc['StackCanary'] = procDict[pid]['StackCanary']
  curProc['CLIArguments'] = procDict[pid]['CLIArguments']
  curProc['SumMD5'] = procDict[pid]['SumMD5']
  curProc['SumSHA1'] = procDict[pid]['SumSHA1']
  curProc['SumSHA256'] = procDict[pid]['SumSHA256']
  curProc['SumSHA512'] = procDict[pid]['SumSHA512']
  #Insert curProc data into our printList
  Insert_Print_List(curProc)

#If debug mode is 'write'
def Write_If_Debug():
  if 'recall-out' in argMap:
    print('Writing debug to %s' % debugRecallFile)
    with io.open(debugRecallFile, 'w', encoding='utf8') as jsonFile:
      raw = json.dumps({'data': debugRecall, 'version': VERSION}, ensure_ascii=True)
      jsonFile.write(unicode(raw))

#If debug mode is 'read'
#No error check is done to know if it is successful
def Read_Debug_Recall():
  global debugRecall
  if 'recall-in' in argMap:
    f = open(debugRecallFile, 'r')
    raw = f.read()
    debugRecall = json.loads(raw)['data']
    print('Load size: %d' % len(debugRecall))

#Writes the information to a CSV to be used later in scoring
def Write_To_File():
  if (DEBUG > 0):
    print("Write_To_File()------------------------------------------------------------------------")
  #Open CSV to append values
  f = open(outFile, "a")
  #Iterate over printList and print all contents to file
  for x in printList:
    #NOTE: Had to build string manually; iteration over the object didn't produce expected order
    cur = infoGen.String(x)
    if (DEBUG > 2):
      print("Outputting to CSV: |"+cur+"|")
    #Write data to file
    f.write(cur.decode('utf-8'))
    #Write newline to file
    f.write('\n'.decode('utf-8'))

  #Note: must encode in utf-8 to write string to CSV
  #ensure file is closed
  f.close()

def Reset_Values():
  global SysASLR, ProcASLR, PIE_process, CurrentProc
  #Reset vars that determine ASLR
  SysASLR = 'ScanError'
  ProcASLR = 'ScanError'
  PIE_process = 'ScanError'
  #Reset CurrentProc values
  
  CurrentProc = infoGen.CreateBlank()
  #CurrentProc['DetectionTime'] =  ScanTimeString
#-----------------------Binary Analysis Functions ------------------------------
#Calculates when the process was created and converts the date into scoring format
# sets CurrentProc[ProcessCreatedOn]
def Proc_Created_On(pid):
  if(DEBUG > 0):
    print('Proc_Created_On() |'+str(pid)+'|------------------------------------')
  #Get the amount of time the process has been up, in seconds
  et, e = Popen_Wrapper(Popen(shlex.split('ps -eo pid,etimes'), 
                             shell=False, stdout=PIPE, stderr=PIPE))
  elapsed, e = Popen_Wrapper(Popen(shlex.split('grep -w '+str(pid)), 
                             shell=False, stdout=PIPE, stderr=PIPE, stdin=PIPE), et)
  #Remove extra whitespaces and trailing whitespace
  elapsed = ' '.join(str(elapsed).split())
  #split into array
  elapsed = elapsed.split(' ')
  #assign elapsed time (first element is the PID used to ID the time)
  if len(elapsed) > 1:
    elapsed = elapsed[1]
    if(DEBUG >1):
      print('Elapsed time in seconds: |'+elapsed+'|')
    #Convert the elapsed time into a datetime object
    date = datetime.fromtimestamp(time.time() - float(elapsed))
    #Convert datetime to format we want
    date = Convert_Date(str(date))
    if(DEBUG > 0):
      print('|'+str(date)+'|')
  else:
    date = ''
  CurrentProc['ProcessCreatedOn'] = date

#Takes in a file path then returns the description and version of the file
#sets     CurrentProc['FileDescription'] && CurrentProc['FileVersion']
def File_Info():
  path = CurrentProc['ProcessPath']
  if(DEBUG > 0):
    print('File_Info() |'+path+'|------------------------------------')
  #Check for valid path
  if(path == ''):
    CurrentProc['FileVersion']= ''
    CurrentProc['FileDescription'] = ''
    return
  #Get file header and filter for version
  vt, e = Popen_Wrapper(Popen(shlex.split('readelf -h \''+path+"\'"), 
                             shell=False, stdout=PIPE, stderr=PIPE))
  version, e = Popen_Wrapper(Popen(shlex.split("grep -w 'Version' "), 
                             shell=False, stdout=PIPE, stderr=PIPE, stdin=PIPE), vt)
  #Get brief description of file
  description, e2 = Popen_Wrapper(Popen(shlex.split('file -b \''+path+"\'"), 
                                  shell=False, stdout=PIPE, stderr=PIPE))
  #Clean version string
  version = Clean_String(str(version))
  #Clean description string
  description = Clean_String(str(description))
  if(DEBUG > 0):
    print('Description: |'+str(description)+'|')
    print('Version: |'+str(version)+'|')
  #Split version into list to pull out version info
  version = version.split(':')
  #Split description into list to pull out description info
  description = description.split(',')
  
  #Verify that the proc exists
  if('Error:' in version):
    if(DEBUG > 0):
      print('ERROR: '+path+' does not exist in this context')
  else:
    CurrentProc['FileVersion'] = version[1] if len(version) > 1 else ''
    CurrentProc['FileDescription'] = description[0] if len(description) > 0 else ''
    if(DEBUG > 0):
      print('File Description: |'+CurrentProc['FileDescription']+'| File Version: |'+CurrentProc['FileVersion']+'|')

#Accepts a process pid, gets and sets the path of the given process' binary
#sets CurrentProc['ProcessPath']
#Learned: Location of process binaries, how to select specific output of tokenized string
def Proc_Path(pid):
  if(DEBUG > 0):
    print('Proc_Path() |'+str(pid)+'|------------------------------------')
    print(CurrentProc['ProcessPath'])
  #Check for valid pid
  if(pid == 0):
    ProcessPath=''
    return
  #Grab file info
  if(DEBUG > 1):
    print("Command: |"+'readlink -f '+'/proc/'+str(pid)+'/exe|')
  path, e = Popen_Wrapper(Popen(shlex.split('readlink -f '+'/proc/'+str(pid)+'/exe'), 
                          shell=False, stdout=PIPE, stderr=PIPE))
  #Fixes (deleted) part at end that is sometimes there
  path = path.replace('\n', '').strip()
  if(DEBUG > 2):
    print('Path returned from readlink -f: |'+path+'|')
  #Check for broken symbolic link
  if('deleted' in path):
    path = path.split()
    path = path[0] if len(path) > 0 else ''
  #Grab last element, which is the file description
  CurrentProc['ProcessPath'] = path
  if(DEBUG > 1):
    print('ProcessPath: |'+CurrentProc['ProcessPath']+'|')

#sets CurrentProc['ProcessName']
#Uses the currently set ProcessPath and parses out the ProcessName
def Proc_Name():
  name = str(CurrentProc['ProcessPath'])
  if '/' in name:
    name = name.split('/')
    CurrentProc['ProcessName'] = name[len(name)-1]
  else:
    CurrentProc['ProcessName'] = name if len(CurrentProc['ProcessName']) == 0 \
                                      else CurrentProc['ProcessName']

#Takes in a PID and sets the username
def Proc_User_Name(pid):
  if(DEBUG > 0):
    print('Proc_User_Name() |'+str(pid)+'|------------------------------------')
  #Find username associated with pid
  #user:32 sets username column to 32 chars to avoid truncated names e.g. 'usernam+'
  nt, e = Popen_Wrapper(Popen(shlex.split('ps axo user:32,pid'), 
                             shell=False, stdout=PIPE, stderr=PIPE))
  name, e = Popen_Wrapper(Popen(shlex.split('grep ' + str(pid)), 
                             shell=False, stdout=PIPE, stderr=PIPE, stdin=PIPE), nt)
  #remove extra spaces
  name = ' '.join(name.split())
  #Convert to array
  name = name.split(' ')
  #Assign ProcessName
  CurrentProc['UserName']=name[0]
  if(DEBUG > 1):
    print('UserName: |'+ CurrentProc['UserName']+'|')

#-----------------------Process Analysis Functions ----------------------_------

#Sets the host and port names for local and remote based on inode number
def Host_Port_Name(inode):
  #Convert to string to reduce processing
  inode = str(inode)
  #Holds output line we want
  line = ''
  #Used to skip logic that sets variables
  found = 0
  if(DEBUG > 0):
    print('Host_Port_Name() for: |'+inode+'|------------------------------------')
  #TODO this should really be a map, O(n) currently 
  for x in netstat_names:
    if (inode in x):
      if(DEBUG > 1):
        print('Found a matchng line')
      line = x
      #set found to true
      found = 1
      break
  #return if no match was found
  if(found == 0):
    if(DEBUG > 1):
      print('No match for |'+inode+'| was found')
    return
  #Remove extra whitespace and trailing newline chars-
  line = Clean_String(line)
  if(DEBUG > 1):
    print('Line containing '+inode+': |'+line+'|')
  #split line into list
  line = line.split(' ')
  #Capture local information
  local = line[3]
  #Split into localHostName localPortName
  local = local.split(':')
  #Check if we're parsing abbreviated IPv6, not a hostname
  if(len(local) > 2):
    local[0] = ''
    local[1] = local[len(local)-1]
  #Capture remote information
  remote = line[4]
  #Split into remoteHostName remotePortName
  remote = remote.split(':')
  if(len(remote) > 2):
    remote[0] = ''
    remote[1] = remote[len(remote)-1]
  if(DEBUG > 2):
    print('local output: |'+str(local)+'|')
    print('remote output: |'+str(remote)+'|')
  
  #set local host name and port name
  CurrentProc['LocalHostName'] = local[0]
  #Check if port name is resolved
  if(Is_Int(local[1])):
    CurrentProc['LocalPortName'] = ''
  else:
    CurrentProc['LocalPortName'] = local[1]
  #If connection is not established, then names aren't resolved
  if('ESTABLISHED' in line):
    #set remote host name and port name
    CurrentProc['RemoteHostName'] = remote[0]
    #Check if port name is resolved
    if(Is_Int(remote[1])):
      CurrentProc['RemotePortName'] = ''
    else:
      CurrentProc['RemotePortName'] = remote[1]
  else:
    CurrentProc['RemoteHostName'] = ''
    CurrentProc['RemotePortName'] = ''

  if(DEBUG > 1):
    print('LocalHostName: |'+CurrentProc['LocalHostName']+'|  LocalPortName: |'+CurrentProc['LocalPortName']+'|')
    print('RemoteHostName: |'+CurrentProc['RemoteHostName']+'|  RemotePortName: |'+CurrentProc['RemotePortName']+'|')

#----------------------checksec functions
#NOTE: The final value of ASLR is a combination of three sub-components to ASLR
#   SysASLR, PieBinary, and PieProcess must be true to set overall ASLR to true
#Source: checksec.sh
#Detects if ASLR is enabled for the system
#TODO: Update function to use python, not call the script
#NOTE: Calling script may be the best way to evaluate ASLR
def ASLR(pid):
  global SysASLR
  if(DEBUG > 0):
    print('Sys_ASLR() |'+str(pid)+'|------------------------------------')
  ot, e = Popen_Wrapper(Popen(shlex.split("sysctl -a"), 
                             shell=False, stdout=PIPE, stderr=PIPE))
  output, e = Popen_Wrapper(Popen(shlex.split("grep 'kernel.randomize_va_space = '"), 
                             shell=False, stdout=PIPE, stderr=PIPE, stdin=PIPE), ot)
  if('0' in output):
    SysASLR = 'DISABLED'
  elif('1' in output):
    SysASLR = 'PARTIAL'
  elif('2' in output):
    SysASLR = 'TRUE'
  else:
    SysASLR = 'ScanError'

#Check binary for PIE support, which implies that ASLR is enabled
#modified from checksec.sh
def PIE_Binary(path):
  if(DEBUG > 0):
    print("PIE_Binary() |"+path+'|------------------------------------')
  #Check if PID is valid, return set to ScanError if not
  if(path==''):
    CurrentProc['PIE-Binary'] = 'ScanError'
    if(DEBUG > 0):
      print('PIE_binary: '+CurrentProc['PIE-Binary'])
    return
  #Get binary information using readelf and grep for the Type
  ot, e = Popen_Wrapper(Popen(shlex.split('readelf -h \''+path+"\'"), 
                             shell=False, stdout=PIPE, stderr=PIPE))
  output, e = Popen_Wrapper(Popen(shlex.split("grep 'Type:'"), 
                             shell=False, stdout=PIPE, stderr=PIPE, stdin=PIPE), ot)
  output = Clean_String(str(output))
  #Check what type the binary is
  if('EXEC' in output):
    CurrentProc['PIE-Binary'] = 'FALSE'
  elif("DYN" in str(output)):
    CurrentProc['PIE-Binary'] = 'TRUE'
  else:
    CurrentProc['PIE-Binary'] = 'ScanError'
  if(DEBUG > 0):
    print('PIE_binary: '+str(CurrentProc['PIE-Binary']))

#Evaluates if the process supports PIE and saves the result
#modified from checksec.sh
def PIE_Process(pid):
  global PIE_process
  if(DEBUG > 0):
    print('PIE_Process(): |'+str(pid)+'|------------------------------------')
  #Check if PID is valid, return set to ScanError if not
  if(pid==0):
    PIE_process = 'ScanError'
    if(DEBUG > 0):
      print('PIE_process: '+PIE_process)
    return
  #Get binary information using readelf and grep for the Type
  ot, e = Popen_Wrapper(Popen(shlex.split('readelf -h /proc/'+str(pid)+"/exe"), 
                             shell=False, stdout=PIPE, stderr=PIPE))
  output, e = Popen_Wrapper(Popen(shlex.split("grep 'Type:'"), 
                             shell=False, stdout=PIPE, stderr=PIPE, stdin=PIPE), ot)
  output = Clean_String(str(output))
  #Check what type the binary is
  if('EXEC' in output):
    PIE_process = 'FALSE'
  elif("DYN" in str(output)):
    PIE_process = 'TRUE'
  else:
    PIE_process = 'ScanError'
  if(DEBUG > 0):
    print('PIE_process: '+str(PIE_process))

#Check for execute permissions being enabled on the binary
#modified from checksec.sh
def DEP_NX_Enabled(path):
  if(DEBUG > 0):
    print("DEP_NX_Enabled() |"+path+'|------------------------------------')
  #Check if PID is valid, return set to ScanError if not
  if(path==''):
    CurrentProc['DEP'] = 'ScanError'
    if(DEBUG > 0):
      print('DEP: '+CurrentProc['DEP'])
    return
  #Get file headers and find info on GNU_STACK, include next matching line
  ot, e = Popen_Wrapper(Popen(shlex.split('readelf -l \''+path+"\'"), 
                             shell=False, stdout=PIPE, stderr=PIPE))
  output, e = Popen_Wrapper(Popen(shlex.split("grep -A 1 'GNU_STACK'"), 
                             shell=False, stdout=PIPE, stderr=PIPE, stdin=PIPE), ot)
  output = Clean_String(str(output))
  #Show line matching GNU_STACK
  if(DEBUG > 2):
    print(output)
  #Check what type the binary is
  if('RWE' in output):
    CurrentProc['DEP'] = 'TRUE'
  else:
    CurrentProc['DEP'] = 'FALSE'
  if(DEBUG > 0):
    print('DEP: '+CurrentProc['DEP'])

#Checks for RELRO support and saves the result
#modified from checksec.sh
def RELRO(path):
  if(DEBUG > 0):
    print("RELRO() |"+path+'|------------------------------------')
  #Check if PID is valid, return set to ScanError if not
  if(path==''):
    CurrentProc['RELRO'] = 'ScanError'
    if(DEBUG > 0):
      print('RELRO: '+CurrentProc['RELRO'])
    return
  
  #Get program headers for input proc path, read all the output
  output, e = Popen_Wrapper(Popen(shlex.split('readelf -l \''+path+"\'"), 
                            shell=False, stdout=PIPE, stderr=PIPE))
  #Check if we have permissions to read program header inforamation
  if('Program Headers' in output):
    #Check for RELRO support
    if('GNU_RELRO' in output):
      #Get info on what type "t" of RELRO is supported from the dynamic section
      t, e = Popen_Wrapper(Popen(shlex.split('readelf -d \''+path+"\'"), 
                           shell=False, stdout=PIPE, stderr=PIPE))
      #Clean string of garbage chars
      t = Clean_String(str(t))
      if('BIND_NOW'):
        CurrentProc['RELRO']='TRUE'
      else:
        CurrentProc['RELRO']='PARTIAL'
    else:
      CurrentProc['RELRO']='FALSE'
      if(DEBUG > 0):
        print("No RELRO support found")
  else:
    CurrentProc['RELRO']='ScanError'
    if(DEBUG > 0):
      print("Cannot read Program Headers. Please run as root")
  if(DEBUG > 0):
    print('RELRO: '+CurrentProc['RELRO'])

#Checks for stack canary support and saves the result
#modified from checksec.sh
def Stack_Canary(path):
  if(DEBUG > 0):
    print("RELRO() |"+path+'|------------------------------------')
  #Check if PID is valid, return set to ScanError if not
  if(path==''):
    CurrentProc['RELRO'] = 'ScanError'
    if(DEBUG > 0):
      print('RELRO: '+CurrentProc['RELRO'])
    return
  #Get symbol table for input path
  output, e = Popen_Wrapper(Popen(shlex.split('readelf -s \''+path+"\'"), 
                            shell=False, stdout=PIPE, stderr=PIPE))
  #Check if we have permissions to read Symbol Table
  if('Symbol table' in output):
    #Check for StackCanary support
    if('__stack_chk_fail' in output):
      CurrentProc['StackCanary'] = 'TRUE'
      if(DEBUG > 0):
        print("Stack Canary Found")
    else:
      CurrentProc['StackCanary'] = 'FALSE'
      if(DEBUG > 0):
        print("Stack Canary DNE")
  else:
    CurrentProc['StackCanary']='ScanError'
    if(DEBUG > 0):
      print("Cannot read Program Headers. Please run as root")
  if(DEBUG > 0):
    print('StackCanary: '+CurrentProc['StackCanary'])


class Scanner():
  def __init__(self):
    self._scans = []  # List of tuples (time, bulk_scan)
    self._raw_lines = {}

  def _post_scan(self):
    # Parse out duplicates, keeping oldest entry.
    # argMap add `scan-recent-time` to have most recent scan proc occured in.
    for scan in self._scans:
      time = scan[0]
      lines = scan[1].split('\n')[self._get_n_hdr():]  # Split into lines and skip header
      for line in lines:
        if len(line) == 0:
          continue
        uid = self._get_id(line)  # Leave in string as int is not needed
        if 'scan-recent-time' in argMap:
          self._raw_lines[uid] = (time, line)
        else:
          cond = self._raw_lines.get(uid) == None
          self._raw_lines[uid] = (time, line) if cond else self._raw_lines[uid]
  
  def _get_id(self, line):
    pass
  
  def _get_n_hdr(self):
    return 1
  
  def scan(self):
    pass
  
  def parse(self):
    pass


class ProcScan(Scanner):

  def scan(self):
    # To allow scan over time just insert raw strings
    # May still have duplicates if CPU/MEM usage change
    # Still uses first one as CPU/MEM stats are not used
    if 'no-proc' in argMap:
      return
    ps_raw, e = Popen_Wrapper(Popen(shlex.split('ps -eo "ruser pid ppid command"'), 
                              shell=False, stdout=PIPE, stderr=PIPE))
    Detection_Time()
    self._scans.append((ScanTimeString, ps_raw)) 

  def _get_id(self, line):
    return line.split()[1]  # Use pid as id
    
  def parse(self):
    global ScanTimeString
    if 'no-proc' in argMap:
      print(' Skipping...')
      return
    # COMMAND differs, 1. -bash, 2. [procss]
    Reset_Values()

    #Title order: USER PID CPU MEM VSZ RSS TTY STAT TIME COMMAND
    title = {'USER': 0, 'PID': 1, 'PPID': 2, 'COMMAND': 3}
    self._post_scan()
    ps_lines = self._raw_lines
    pb = Progress_Bar(len(self._raw_lines))
    for uid in self._raw_lines:
      ScanTimeString = ps_lines.get(uid)[0]
      ps_line = ps_lines.get(uid)[1]
      pb.Print()
      pb.Inc(1)
      ps_args = ps_line.split()
      # Skip any not in right format
      if len(ps_args) < len(title):
        continue
      cmd_args = ''
      if len(ps_args) > len(title):
        cmd_args = ' '.join(ps_args[title['COMMAND']+1:])  #Everying after command is arg
      if DEBUG > 3:
        print('proc arr %s', str(ps_line))
        print('PS out:')
        print(ps_args)
        print('Args:')
        print(cmd_args)
      cmd_raw = ps_args[title['COMMAND']]
      # Kernel proc can have [th ht h]
      if len(cmd_raw) > 0 and cmd_raw[0] == '[':
        cmd_raw = ' '.join(ps_args[title['COMMAND']:])
        cmd_args = ''
      if len(cmd_raw) == 0:
        continue
      cmd_path = ''
      cmd_name = ''
      is_kernel = '[' == cmd_raw[0]
      is_renamed = '(' == cmd_raw[0]
      is_path = '/' in cmd_raw and not is_kernel and not is_renamed
      #if len(cmd_raw) > 0 and cmd_raw[-1] == ':':
      #  cmd_raw = cmd_raw[:-1]
      # -bash
      if len(cmd_raw) > 0 and '-' == cmd_raw[0]:
        cmd_name = cmd_raw[1:]
        cmd_path = cmd_name
      elif is_path:
        #Usually normal path /something/something but not [something/0]
        cmd_split = cmd_raw.split('/')
        cmd_name = cmd_split[-1] if len(cmd_split) > 0 else cmd_raw
        cmd_path = cmd_raw
      elif is_kernel:
        cmd_name = cmd_raw
        #Leave cmd_path blank because it is usually kernal process
        cmd_path = ''
        if 'no-kernel' in argMap:
          continue
      else:
        cmd_name = cmd_raw.split()[0]
        cmd_path = cmd_raw

      CurrentProc['ProcessName'] = cmd_name
      CurrentProc['ProcessPath'] = cmd_path
      CurrentProc['PID'] = int(ps_args[title['PID']])
      CurrentProc['PPID'] = int(ps_args[title['PPID']])
      CurrentProc['Protocol'] = 'none'
      CurrentProc['UserName'] = ps_args[title['USER']]
      #Check if can find absolute path
      if not is_path and not is_kernel:
        Proc_Path(ps_args[title['PID']])
        #Change is_path
        is_path = '/' in CurrentProc['ProcessPath'] and not is_kernel and not is_renamed

      #CurrentProc['INODE'] = ino
      CurrentProc['CLIArguments'] = cmd_args
      if CurrentProc['PID'] in procDict.keys():
        if(DEBUG > 0):
          print ('Duplicate Entry')
        #No duplicate for proc
        #Duplicate_Entry(CurrentProc['PID'])
      else:
        #Get process information if not kernal or renamed 
        #Check format is /somethin/something
        if is_path:
          Binary_Wrapper()
        else:
          Process_Wrapper()
        #Add proc to dictionary
        Add_Entry(CurrentProc['PID'])
      Reset_Values()
    pb.End()

class NamedPipeScan(Scanner):

  def scan(self):
    if 'no-n-pipes' in argMap:
      return
    pipe_raw, e = Popen_Wrapper(Popen(shlex.split('lsof -n'), shell=False, stdout=PIPE,
                                      stderr=PIPE))
    Detection_Time()
    self._scans.append((ScanTimeString, pipe_raw))
    
  def _get_id(self, line):
    # Really only the pid + tid + fd are only needed by others don't
    return line  # We must use line as lsof is unique by all together

  #Shows currently active with at least one r&w named pipes.
  #Ignore `lsof: WARNING: can't stat() fuse.gvfsd-fuse
  def parse(self):
    global ScanTimeString
    if 'no-n-pipes' in argMap:
      print(' Skipping...')
      return
    # TODO change lsof to grep pipe, and add if statement that does readlink

    Reset_Values()
    pipe_table = {}  #Keep tack of repeats 
    #TID could be blank
    #Device is %d,%d
    #unnamed pipes link file is at /proc/<pid>/fd/<fd>, readlink can be used on it

    #Title Order: CMD PID TID USER FD TYPE DEVICE SIZE/OFF NODE NAME
    title = {'CMD': 0, 'PID': 1, 'TID': 2, 'USER': 3, 'FD': 4, 'TYPE': 5,
             'DEV': 6, 'SIZE_OFF': 7, 'NODE': 8, 'NAME': 9}
    
    #FIFO are pipes and `grep -v pipe` gets rid of unnamed pipes
    self._post_scan()
    pipe_lines = self._raw_lines
    pb = Progress_Bar(len(pipe_lines))
    for uid in pipe_lines:
      ScanTimeString = pipe_lines.get(uid)[0]
      pipe_line = pipe_lines.get(uid)[1]
      pb.Print()
      pb.Inc(1)
      pipe_args = pipe_line.split()
      if len(pipe_args) == 0:
        continue
      #Fix missing slots
      try:
        int(pipe_args[title['TID']])
      except ValueError:
        # Put dummy value
        pipe_args.insert(title['TID'], '0')

      #Filter out normal files, only pipes
      if pipe_args[title['TYPE']] != 'FIFO':
        continue;
      #Filter out unnamed pipes
      if pipe_args[title['NAME']] == 'pipe':
        continue;
      if DEBUG > 3:
        print('Lsof out:')
        print(pipe_args)
   
      #Seperate w/r/u
      state = 'established'
      if (('w' in pipe_args[title['FD']] or 'u' in pipe_args[title['FD']])
           and (pipe_args[title['NAME']] not in pipe_table)):
        state = 'listening'
        pipe_table[pipe_args[title['NAME']]] = 0  #Place holder
      extra = 'read&write'
      if 'w' in pipe_args[title['FD']]:
        extra = 'write'
      elif 'r' in pipe_args[title['FD']]:
        extra = 'read'

      #Get date last accessed as created is always dash
      date = ''
      try:
        o, e = Popen_Wrapper(
                      Popen(shlex.split('stat --format="%%x" %s' % 
                               pipe_args[title['NAME']]), shell=False, stdout=PIPE, stderr=PIPE))
        elapsed = ' '.join(o.split()[:2])
        #Float at end messes up time so get rid of
        date = Convert_Date('.'.join([elapsed.split('.')[0], '0']))
      except:
        date = ''
      if(DEBUG > 0):
        print('|'+str(date)+'|')

      pid = int(pipe_args[title['PID']])
      CurrentProc['ProcessName'] = procDict[pid]['ProcessName'] if procDict.get(pid) != None else ''
      CurrentProc['PID'] = pid
      CurrentProc['ProcessPath'] = procDict[pid]['ProcessPath'] if procDict.get(pid) != None else ''
      CurrentProc['Protocol'] = 'pipe'
      CurrentProc['LocalAddress'] = pipe_args[title['NAME']]
      CurrentProc['LocalPort'] = pipe_args[title['NODE']]
      CurrentProc['RemoteAddress'] = pipe_args[title['NAME']]
      CurrentProc['RemotePort'] = pipe_args[title['NODE']]
      CurrentProc['State'] = state
      CurrentProc['UserName'] = pipe_args[title['USER']]
      CurrentProc['INODE'] = pipe_args[title['NODE']]
      CurrentProc['ProcessCreatedOn'] = str(date)
      CurrentProc['ExtraConnectionInfo'] = extra
      #Add proc to dictionary
      if CurrentProc['PID'] in procDict.keys():
        Duplicate_Entry(CurrentProc['PID'])
      else:
        Add_Entry(CurrentProc['PID'])
      Reset_Values()
    pb.End()
    

#--------------------------------Wrapper Functions
#parses input from netstat and performs security checks on each process
#Keeping this here for reference of which var is being parsed:
class NetworkScan(Scanner):
  def _get_id(self, line):
    return ' '.join(line.split()[3:])

  def _get_n_hdr(self):
    return 2

  def scan(self):
    global netstat_names
    if 'no-network' in argMap:
      return
    net_o, net_e = Popen_Wrapper(Popen(shlex.split('netstat -uentap'), 
                                 shell=False, stdout=PIPE, stderr=PIPE))
    net2_o, net2_e = Popen_Wrapper(Popen(shlex.split('netstat -ueWtap'),
                                   shell=False, stdout=PIPE, stderr=PIPE))
    netstatTemp = []
    
    netstatTemp.append(net2_o)
    netstatTemp = ' '.join(str(netstatTemp).split())
    netstatTemp = netstatTemp.split('\\n')
    del netstatTemp[0]
    del netstatTemp[0]
    if(DEBUG > 2):
      print '---------------NETSTAT-NAMES------------------'
      print netstatTemp
    netstat_names.update(netstatTemp)
    Detection_Time()
    self._scans.append((ScanTimeString, net_o))
    

  def parse(self):
    global ScanTimeString
    if 'no-network' in argMap:
      print(' Skipping...')
      return
    global CurrentProc
    netstat_var = {0: 'Protocol', 1: 'LocalAddress', 2: 'LocalPort', 3: 'RemoteAddress', 4: 'RemotePort', 5: 'State', 6: 'UID', 7: 'INODE', 8: 'PID', 9: 'ProcessName' }
    #counter
    counter=0
    #holds netstat output
    #holds netstat output that includes host and port names
    #iterate over entries in output
    self._post_scan()
    output = self._raw_lines
    pb = Progress_Bar(len(output))
    for uid in output:
      pb.Print()
      pb.Inc(1)
      ScanTimeString = output.get(uid)[0]
      line = output.get(uid)[1]
      #reset counter
      counter = 0
      #Split elements into list
      varlist=line.split()
      #Check length of varlist to ensure it's valid / not garbage values
      if(len(varlist) < 7):
        #found an invalid or incomplete entry, skip over
        continue
      #Check if we're parsing udp and require a blank 'STATE' entry
      if('udp' in varlist[0]):
        #Insert blank entry to 'STATE' index
        varlist.insert(5,' ')
      #Check for extra entries in list and trim if needed
      if(len(varlist) > 8):
        #Cut off any extra entries
        del varlist[9:]
      #remove Recv-Q Send-Q entries from input
      del varlist[1:3]
      
      if(DEBUG > 1):
        print("varlist: "+ str(varlist))

      #Iterate over each variable in varlist
      # Varlist ex: tcp ip:port ip:port LISTEN User Inode PID/Name
      for var in varlist:
        #DEBUG
        if(DEBUG > 1):
          print ('counter: |'+str(counter)+'|')
          #Show what variable we are parsing for and its intended value
          print ('Var:|'+netstat_var[counter]+'| Val: |'+var+'|')
        
        #Check if we're parsing 'address:port' for local or remote
        #3 because it is incremented to account for port being its own field
        if(counter == 1) or (counter == 3):
          x= var.split(':')
          port = x[len(x)-1]
          #Check Protocol for IPv4, IPv6 connections
          if('6' in CurrentProc[netstat_var[0]]):
            #Get port as last item in list, set to temp item to reduce processing in loop
            #String used to build IPv6 address
            addr = ''
            for y in x:
              #Check if we are at the end of the string
              if(y == port):
                #Remove last colon from address
                addr = addr[0:len(addr)-1]
                if(DEBUG>2):
                    print('addr |'+addr+'|')
                break
              addr += str(y)+':'
            #set IPv6 Address
            CurrentProc[netstat_var[counter]] = addr
            counter+=1
            #set port, check for empty port value
            if(port == '*'):
              CurrentProc[netstat_var[counter]] = ''
            else:
              CurrentProc[netstat_var[counter]] = port
          #Parsing IPv4, no special processing required. 
          else:
            #set IPv4 address
            CurrentProc[netstat_var[counter]] = x[0]
            counter+=1
            #set port
            #Check if empty :::port
            if(port == '*'):
              CurrentProc[netstat_var[counter]] = ''
            else:
              CurrentProc[netstat_var[counter]] = x[1]
          if(DEBUG > 0):
            print('Address: |'+CurrentProc[netstat_var[counter-1]]+'| Port: |'+CurrentProc[netstat_var[counter]]+'|')
        #Check if we're parsing State
        elif(counter == 5):
          #Check if current line from netstat is UDP (since it has no state)
          if('udp' in CurrentProc['Protocol']):
              CurrentProc[netstat_var[counter]] = ''
          else:
              if(var == 'LISTEN'):
                CurrentProc[netstat_var[counter]] = 'listening'
              elif(var == 'ESTABLISHED'):
                CurrentProc[netstat_var[counter]] = 'established'
              elif('TIME_WAIT' in var):
                CurrentProc[netstat_var[counter]] = 'time wait'
              elif('FIN_WAIT' in var):
                CurrentProc[netstat_var[counter]] = 'fin wait'
              else:
                CurrentProc[netstat_var[counter]] = var
        #Check if we're parsing 'PID/ProcessName'
        elif(counter == 8):
          #Check if there's a valid PID/ProcessName
          if(var == '-'):
            if DEBUG > 3:
              print('Fixing dash PID')
            x = ['0','-']
          else:
            x=var.split('/')
          #set PID
          CurrentProc[netstat_var[counter]] = int(x[0])
          #Increment counter
          counter+=1
          #Set host and port names for local and remote:
          Host_Port_Name(CurrentProc['INODE'])
          
          if(DEBUG > 0):
            print('PID: |'+str(CurrentProc[netstat_var[counter-1]])+'| ProcessName: |'+CurrentProc[netstat_var[counter]]+'|')
          #Check if PID is already in the dictionary, indicating it's a duplicate
          if CurrentProc['PID'] in procDict.keys():
            if(DEBUG > 0):
              print ('Duplicate Entry')
            #Copy over values
            Duplicate_Entry(CurrentProc['PID'])
          else:
            #Get process information
            #Set ProcessPath
            Proc_Path(CurrentProc['PID'])
            #Set ProcessName
            Proc_Name()
            Process_Wrapper()
            #Get Binary information, evaluate ASLR
            Binary_Wrapper()
            #Add proc to dictionary
            Add_Entry(CurrentProc['PID'])
          #Reset values
          Reset_Values()
          break
        else:
          #Use the netstat value as a key for CurrentProc and set value to var
          CurrentProc[netstat_var[counter]] = var
        #increment counter
        counter+=1
        if(DEBUG>1):
          print(CurrentProc)
    pb.End()
    #NOTE/TODO:To get port name, use: socket.getservbyport(sock#)

def Parse_Domain_Sockets():
  global CurrentProc
  domain_var = {0: 'Protocol', 1: 'State', 2: 'INODE', 3: 'PID', 4: 'ProcessPath'}
  Reset_Values()
  #DEBUG
  if(DEBUG > 0):
    print('Parse_Domain_Sockets()------------------------------------------------------------------------')
  #counter
  counter=0
  #holds netstat output
  output = []
  #NOTE: must instert into list to read in special characters for parsing by line e.g. '\n'
  #Get netstat output and append to list
  o, e = Popen_Wrapper(Popen(shlex.split('netstat -xp'), shell=False, stdout=PIPE, stderr=PIPE))
  output.append(o)
  #remove duplicate spaces
  output = ' '.join(str(output).split())
  #split netstat output by newline
  output = output.split('\\n')
  #remove first two lines of output from netstat; they do not contain data
  del output[0]
  del output[0]
  #Show all of netstat output
  if(DEBUG > 2):
    print('Output:')
    print output
  #iterate over entries in output
  for line in output:
    #reset counter
    counter = 0
    #Split elements into list
    varlist=line.split(' ')
    
    #Find position to slice to in list for entry removal
    p = 0
    for y in varlist:
        if(y ==']'):
          #remove RefCnt and Flag entries from input
          del varlist[0:p+1]
          break
        #increment coutner
        p += 1 

    #Get rid of extra at end if there is one
    if varlist[len(varlist)-1] == '':
      varlist = varlist[:len(varlist)-1]

    #Check if Type is DGRM; it doesn't have a socket state
    if('DGRAM' in varlist[0]):
        varlist.insert(1,'')
    #Check for blank path entries
    if(len(varlist)==4):
        varlist.insert(4,'');
    
    if(DEBUG > 1):
      print("varlist: "+ str(varlist))
    
    #Check length of varlist to ensure it's valid / not garbage values
    if((len(varlist) < 5) or (len(varlist) > 5)):
        if(DEBUG>2):
            print("Skipping entry: "+ str(varlist))
      #skip running checks for entry
        continue
    
    #Iterate over each variable in varlist
    for var in varlist:
      #DEBUG
      if(DEBUG > 1):
        print ('counter: |'+str(counter)+'|')
        #Show what variable we are parsing for and its intended value
        print ('Var:|'+domain_var[counter]+'| Val: |'+var+'|')
      
      if(counter==0):
        CurrentProc['Protocol'] = var
      #Check if we're parsing 'PID/ProcessName'
      elif(counter==3):
        #Check if there's a valid PID/ProcessName
        if(var == ''):
          x = ['0','-']
        else:
          x=var.split('/')
        #set PID
        CurrentProc['PID'] = int(x[0])
        CurrentProc['ProcessName'] = x[1]
        if(DEBUG > 0):
          print('PID: |'+str(CurrentProc[domain_var[counter-1]])+'| ProcessName: |'+CurrentProc['ProcessName']+'|')
        
      #Check if we're parsing path
      elif(counter==4):
        #TODO: Remove duplicate entries with the exception of PID 1
        #Check if PID is already in the dictionary, indicating it's a duplicate
        if CurrentProc['PID'] in procDict.keys():
          if(DEBUG > 0):
            print ('Duplicate Entry')
          #Copy over values
          Duplicate_Entry(CurrentProc['PID'])
        else:
          #Get process information
          Domain_Process_Wrapper()
          #Add proc to dictionary
          Add_Entry(CurrentProc['PID'])
        #Add proc to dictionary
        #Add_Entry(CurrentProc['PID'])
        #Reset values for globals
        Reset_Values()
      else:
        #Use the netstat value as a key for CurrentProc and set value to var
        CurrentProc[domain_var[counter]] = var
      #increment counter
      counter+=1
      if(DEBUG>1):
        print(CurrentProc)

def Proc_Hashes():
  if 'no-hash' in argMap:
    return
  try:
    if len(CurrentProc['ProcessPath']) == 0:
      raise Exception('Cat oops')
    exe, e = Popen_Wrapper(Popen(shlex.split('cat %s' % CurrentProc['ProcessPath']), 
                           shell=False, stdout=PIPE, stderr=PIPE))
    if len(e) != 0:
      raise Exception('Cat oops')
    CurrentProc['SumMD5'] = hashlib.md5(exe).hexdigest()
    CurrentProc['SumSHA1'] = hashlib.sha1(exe).hexdigest()
    CurrentProc['SumSHA256'] = hashlib.sha256(exe).hexdigest() 
    CurrentProc['SumSHA512'] = hashlib.sha512(exe).hexdigest()
  except:
    CurrentProc['SumMD5'] = 'ScanError';
    CurrentProc['SumSHA1'] = 'ScanError';
    CurrentProc['SumSHA256'] = 'ScanError';
    CurrentProc['SumSHA512'] = 'ScanError';

#Process wrapper for parse_netstat()
def Process_Wrapper():
  pid = int(CurrentProc['PID'])
  if(DEBUG > 0):
    print("Process_Wrapper() |"+str(pid)+'|')
  #Set architecture for process
  Architecture(pid)
  #Calculate and set date process was created, sets ProccessCreatedOn
  Proc_Created_On(pid)
  #Get the username associated with the current running process, sets UserName
  Proc_User_Name(pid)
  #Determine if the process supports PIE, sets PIE_process
  PIE_Process(pid)
  #Check for system ASLR support, sets SysASLR
  ASLR(pid)
  #Set RELRO, Stack Canary, and DEP
  Proc_Check(CurrentProc['ProcessPath'])
  Proc_Hashes()

#Binary wrapper for parse_netstat()
#preconditions: PID and ProcessPath are set in CurrentProc
def Binary_Wrapper():
  File_Info()
  PIE_Binary(CurrentProc['ProcessPath'])
  #Evaluate ASLR
  if ((SysASLR == 'TRUE') and (CurrentProc['PIE-Binary'] == 'TRUE') and (PIE_process == 'TRUE')):
    CurrentProc['ASLR'] = 'TRUE'
  else:
    CurrentProc['ASLR'] = 'FALSE'

#Process wrapper for Parse_Netstat()
def Domain_Process_Wrapper():
  pid = int(CurrentProc['PID'])
  if(DEBUG > 0):
    print("Domain_Process_Wrapper() |"+str(pid)+'|')
  #Set architecture for process
  Architecture(pid)
  #Calculate and set date process was created, sets ProccessCreatedOn
  Proc_Created_On(pid)
  #Get the username associated with the current running process, sets UserName
  Proc_User_Name(pid)
  #Determine if the process supports PIE, sets PIE_process
  PIE_Process(pid)
  #Check for system ASLR support, sets SysASLR
  ASLR(pid)
  #Set RELRO, Stack Canary, and DEP

#Binary wrapper for Parse_Netstat()
#preconditions: PID and ProcessPath are set in CurrentProc
def Domain_Binary_Wrapper():
  File_Info()
  PIE_Binary(CurrentProc['ProcessPath'])
  #Evaluate ASLR
  if ((SysASLR == 'TRUE') and (CurrentProc['PIE-Binary'] == 'TRUE') and (PIE_process == 'TRUE')):
    CurrentProc['ASLR'] = 'TRUE'
  else:
    CurrentProc['ASLR'] = 'FALSE'

#Check if all dependencies are met such as netstat
#A good way to see all commands used. Also good for accidental 
# runs on non linux OS
def Dep_Check():
  #Don't use wrapper as os.popen not needed
  ts = {
    'netstat --version': 'Netstat is needed.',
    'lsof -v': 'lsof is needed.',
    'file --version': 'file is needed.',
    'stat --version': 'stat is needed.',
    'readelf --version': 'readelf is needed.',
    'readlink --version': 'readlink is needed.',
    'grep --version': 'grep is needed.',
    'sysctl --version': 'sysctl is needed.',
    'uname --version': 'uname is needed.',
    'date --version': 'date is needed.',
    'ps --version': 'ps is needed.'
  }
  for t, s in ts.items():
    p = Popen(t, shell=True, stdout=PIPE, stderr=PIPE)
    p.communicate()
    if p.returncode != 0:
      ErrorExit(s)

def Arg_Help():
  print('------------Help Menu------------')
  print('All args are optional, use underscore to use default.')
  print('-h : Display the help menu.')
  print('-H : Do not compute executable hashes.')
  print('-k : Ignore kernel processes.')
  print('-e : Ignore network entries.')
  print('-n : Ignore named pipes.')
  print('-p : Ignore all processes.')
  print('-r : For repeated scan use most recent scan time. Default is first time it was found.')
  print('-l {seconds} : Long scan. Time to scan in seconds.')
  print('-f {file}    : Output file to write results to. Requires filename.')
  print('-d {level}   : (*DEV*)Debug menu. Requires 1 arguments, debug level {int}.')
  print('-o {file}    : (*DEV*)Output recall file. Requires 1 argument, filename.')
  print('-i {file}    : (*DEV*)Simulate run from outputted recall. Requires 1 argument, filename.')
  print('------------   End   ------------')
  sys.exit()

def Arg_Debug(args):
  global DEBUG
  try:
    DEBUG = 4 if args[0] == '_' else int(args[0])
  except ValueError:
    ErrorExit('Debug must be int')

#ARG 'recall-out' 
def Arg_Recall_Out(args):
  global debugRecallFile
  argMap['recall-out'] = 0
  debugRecallFile = 'debug-out.json' if args[0] == '_' else args[0]

#ARG 'recall-in' 
def Arg_Recall_In(args):
  global debugRecallFile
  argMap['recall-in'] = 0
  debugRecallFile = 'debug-out.json' if args[0] == '_' else args[0]

#ARG 'no-kernel' 
def Arg_No_Kernel():
  argMap['no-kernel'] = 0

#ARG 'no-network' 
def Arg_No_Network():
  argMap['no-network'] = 0

#ARG 'no-n-pipes' 
def Arg_No_Named_Pipes():
  argMap['no-n-pipes'] = 0

#ARG 'no-proc' 
def Arg_No_Proc():
  Warn('Named pipes will be missing process information because proc scan was disabled.')
  argMap['no-proc'] = 0

#ARG 'long-scan'
def Arg_Long_Scan(args):
  time = '120' if args[0] == '_' else args[0]
  try:
    argMap['long-scan'] = int(time)
  except:
    ErrorExit('Long scan requires int')

#ARG 'no-hash'
def Arg_No_Hash():
  argMap['no-hash'] = 0

#ARG 'scan-recent-time'
def Arg_Recent_Scan_Time():
  argMap['scan-recent-time'] = 0

#NO ARG
def Arg_Out_File(args):
  global outFile
  outFile = 'BinaryAnalysis.csv' if args[0] == '_' else args[0]


#--------------------------------Main Function
#gathers all of the required information and outputs to a file
def AHA_Main():
  global DEBUG
  if os.getuid() != 0:
    ErrorExit('Please run as root or use sudo')
  Dep_Check()
  
  #Parse args function and number of args to pass
  arg_menu = {
    "h": [Arg_Help, 0],
    "H": [Arg_No_Hash, 0],
    "d": [Arg_Debug, 1],
    "o": [Arg_Recall_Out, 1],
    "i": [Arg_Recall_In, 1],
    "k": [Arg_No_Kernel, 0],
    "e": [Arg_No_Network, 0],
    "n": [Arg_No_Named_Pipes, 0],
    "p": [Arg_No_Proc, 0],
    "l": [Arg_Long_Scan, 1],
    "r": [Arg_Recent_Scan_Time, 0],
    "f": [Arg_Out_File, 1],
  }
  arg_len = len(sys.argv)
  i = 1
  while i < arg_len:
    arg = sys.argv[i]
    if len(arg) <= 1 or arg[0] != '-':
      ErrorExit('check your arguments')
    arg = arg[1:]  #Get rid of dash
    item = arg_menu.get(arg)
    if item == None:
      ErrorExit('%s is not an argument. Do -h for help' % arg)
    if len(sys.argv) < i + 1 + item[1]:
      ErrorExit('%s requires %d extra argument(s)' % (arg, item[1]))
    if DEBUG > 0:
      print(item[0]) 
      print('with params:')
      print(sys.argv[i+1:i+1+item[1]])
    if item[1] > 0:
      item[0](sys.argv[i+1:i+1+item[1]])
    else:
      item[0]()
    i += item[1]
    i += 1
  if outFile == '':
    Arg_Out_File(['_'])
  #Check if there was a variable passed into the system and that it's an integer
  #Get popen recall if DEBUG=5
  Read_Debug_Recall()
  print('For more options use -h')
  print('AHA-Linux-Scraper: Scanning System...')
  #Set current scan time, detection time
  # Detection_Time()
  #Set the column header formating for the CSV file
  columnHeaders = infoGen.Header()
  #Clear out BinaryAnalysis.csv, no wrapper as this is not a used value
  f = open(outFile, 'w+')
  f.write(unicode(columnHeaders+'\n'))
  f.close()
  #place PID 0, initial duplicate entry, in procDict
  procScan = ProcScan()
  nPipeScan = NamedPipeScan()
  netScan = NetworkScan()
  Init_Dict()
  #  Do while
  scan_time = argMap.get('long-scan') if argMap.get('long-scan') != None else 0
  #print(argMap.get('long-scan'))
  start_time = time.time()
  pb = Progress_Bar(scan_time)
  while True:
    diff_time = int((time.time() - start_time))
    pb.Set(diff_time)
    pb.Print()
    netScan.scan()
    procScan.scan()
    nPipeScan.scan()
    if (scan_time - diff_time <= 0):
      break
  pb.End()
  print('Scan done.')

  print('Processing...(0/3)')
  procScan.parse()

  print('\033[F\033[FProcessing...(1/3)')
  netScan.parse()

  print('\033[F\033[FProcessing...(2/3)')
  nPipeScan.parse()
  PrintFull('\033[F\033[FProcessing...(3/3)')

  #print('Scanning Domain Sockets...')
  #Parse_Domain_Sockets()
  #Write info to CSV
  Write_To_File()
  Write_If_Debug()
  print('\n\n\tParse Complete.')
  print('\tSee \'%s\' for output.' % outFile)

if __name__ == '__main__':
  AHA_Main()
